---
layout: default
title: 3. JPA save ì˜ëª»ëœ ì´í•´ë¡œ ë¹„ë¡¯ëœ ì—ëŸ¬
parent: ğŸ“Œ ì‹¤ì‹œê°„ ì±„íŒ…ì„œë²„ í”„ë¡œì íŠ¸
nav_order: 3
---

created at 2022-12-18
{: .label .label-yellow }

### 1. spring-data-jpa `save(S entity)`
ë³¸ í”„ë¡œì íŠ¸ì—ì„œëŠ” Service Layerì—ì„œ íŠ¸ëœì ì…˜ì²˜ë¦¬ë¥¼ ìˆ˜í–‰í•œë‹¤. 
ë˜í•œ RepositoryëŠ” data-jpaë¥¼ ì‚¬ìš©í–ˆë‹¤. 
í•„ìëŠ” ì„œë¹„ìŠ¤ ë‚´ ì˜ˆì™¸ ë°œìƒ ì‹œ, ì›í•˜ëŠ” ê°’ì„ ë°˜í™˜í•˜ê³ ì‹¶ì—ˆë‹¤. 
ë”°ë¼ì„œ serviceë‚´ try-catchë¡œ UniqueKeyViolation ì˜ˆì™¸ë°œìƒ ì‹œ ê°’ì„ ë°˜í™˜í•˜ëŠ” ì½”ë“œë¥¼ ì¶”ê°€í–ˆë‹¤. 
í•˜ì§€ë§Œ, ë¬¸ì œëŠ” data-jpaì—ì„œ ë°œìƒí–ˆë‹¤. saveì‹œ, ë¨¼ì € selectí›„ insertë˜ëŠ” ì ì´ì˜€ë‹¤. 
ë§Œì•½ ê°™ì€ idê°’ì„ ê°€ì§€ëŠ” ê°ì²´ê°€ ì¡´ì¬í•œë‹¤ë©´ persistê°€ ì•„ë‹Œ mergeê°€ ë˜ì—ˆì—ˆë‹¤. 

ì¦‰, saveëŠ” **ì´ë¯¸ ê°™ì€ keyë¥¼ ê°€ì§€ëŠ” ë°ì´í„°ê°€ ì¡´ì¬í•˜ë©´ ë³€ê²½ê°ì§€í•˜ì—¬ updateí•˜ë©°, ì—†ì„ë•Œë§Œ insert**ë˜ê¸°ì— ì˜ˆì™¸ì²˜ë¦¬ê°€ ìˆ˜í–‰ë˜ì§€ ì•Šì•˜ë‹¤.

ì•„ë˜ëŠ” data-jpaì—ì„œì˜ save() ì´ë‹¤.
```java
@Transactional
@Override
public <S extends T> S save(S entity) {
    if (entityInformation.isNew(entity)) {
        em.persist(entity); // ì›í•˜ëŠ” íë¦„. ì´ìª½ìœ¼ë¡œ ê°”ì„ ë•Œ, UniqueKeyViolation ì˜ˆì™¸ ë°œìƒí•œë‹¤.
        return entity;
    } else {
        return em.merge(entity); // í•˜ì§€ë§Œ ì´ìª½ìœ¼ë¡œ í˜ëŸ¬ê°”ë‹¤.
    }
}
```

ë”°ë¼ì„œ data-jpaë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ì„  ë¨¼ì € ì„œë¹„ìŠ¤ì—ì„œ `userRepository.findById(user.getUserId())`ê³¼ì •ì„ í•„ìˆ˜ì ìœ¼ë¡œ ì‘ì„±í•´ì•¼í•œë‹¤.
```java
    // userService
    @Override
    public ResponseEntity<?> save(User user) {
        Optional<User> findUser = userRepository.findById(user.getUserId());
        if (findUser.isPresent()) {
            return ResponseEntity.badRequest().body("í•´ë‹¹ IDë¡œ ë“±ë¡ëœ ìœ ì €ê°€ ì¡´ì¬í•©ë‹ˆë‹¤");
        }
        userRepository.save(user);
        return ResponseEntity.ok(user);
    }
```

### (Appendix) HTTP ì™€ Kafka
ê¸°ì¡´ HTTP í†µì‹ ì„ Kafka ë¡œ ë³€ê²½í•˜ë ¤ê³  í•œë‹¤. ì‹¤í—˜ì ìœ¼ë¡œ ê¸°ì¡´ HTTP í†µì‹  ì¤‘ ìœ ì € íšŒì›ê°€ì…ì„ ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“¤ë ¤ê³ í•œë‹¤. í•˜ì§€ë§Œ Kafka ëŠ” HTTPì™€ ë‹¤ë¥´ê²Œ ê¸°ë³¸ì ìœ¼ë¡œ **Request/Response** í˜•ì‹ì´ ì•„ë‹ˆë‹¤. 
ê·¸ë˜ì„œ í† í”½ì„ `user.create.req` / `user.create.res` ì´ë ‡ê²Œ ë§Œë“¤ì–´ ì¤˜ì•¼ì§€ Request/Response í˜•ì‹ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
> `PostMapping("/user/{userId}")`ì´ëŸ° urlë¡œ ê°€ì ¸ì™”ë˜ ë¶€ë¶„ë“¤ì„ ìˆ˜ì •í•´ì•¼í•œë‹¤. ì¦‰, producerì€ jsonì— **ëª¨ë“  request ë‚´ìš©**ì„ ë‹´ì•„ ì „ì†¡í•˜ê³  consumerì—ì„œ ì´ë¥¼ ì½ëŠ” Request/Response í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•´ì•¼í•œë‹¤.
>
> ì•„ë˜ì˜ í¬ìŠ¤íŒ…ì€ í•„ìê°€ í•˜ê³ ì í•˜ëŠ” ë°©í–¥ì¸ `Kafkaë¥¼ Request/Responseë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒ`ì— ëŒ€í•œ ê³ ì°°ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.
>
> > If you build a modern enterprise architecture and new applications, apply the natural design patterns that work best with the technology. Remember: **Data streaming is a different technology than web services** and message queues! CQRS with event sourcing is the best pattern for most use cases in the Kafka world:
> >
> > ...
> >
> > Nevertheless, it is still only the **second-best approach** and is often an **anti-pattern for streaming data**.
> >
> > reference : [Request-Response in Kafka](https://www.kai-waehner.de/blog/2022/08/12/request-response-with-rest-http-vs-data-streaming-with-apache-kafka/)

### (Appendix) Kafka ì™€ ì›¹ì†Œì¼“
ë˜í•œ ìœ ì €ê°€ íšŒì›ê°€ì…ì„ í–ˆì„ ë•Œ, ê·¸ ê²°ê³¼ë¥¼ ë°›ì•„ì•¼í•œë‹¤. ì´ ë•Œ Server-Sent Event(**SSE**)ë°©ì‹ìœ¼ë¡œ ë°›ëŠ” ë°©ë²•ì´ ìˆë‹¤.
> Server-Sent Events (SSE) is a server push technology where clients receive **automatic server updates through the secure http connection**. SSE can be used in apps like **live stock updates**, that use one way data communications and also helps to replace long polling by maintaining a single connection and keeping a continuous event stream going through it. We used a simple Kafka producer to publish messages onto Kafka topics and developed a reactive Kafka consumer by leveraging Spring Webflux to read data from Kafka topic in non-blocking manner and send data to clients that are registered with Kafka consumer without closing any http connections. This implementation allows us to send data in a fully asynchronous & non-blocking manner and allows us to handle a massive number of concurrent connections. Weâ€™ll cover: â€¢Push data to external or internal apps in near real time â€¢Push data onto the files and securely copy them to any cloud services â€¢Handle multiple third-party apps integrations
>
> reference : [Server Sent Events using Reactive Kafka and Spring Web flux](https://www.confluent.io/ko-kr/events/kafka-summit-europe-2021/server-sent-events-using-reactive-kafka-and-spring-web-flux/)
