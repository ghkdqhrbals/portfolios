---
layout: default
title: ðŸ“Œ Netty ì•„í‚¤í…ì²˜ ë° ë™ìž‘ê³¼ì •
parent: ðŸ“Œ Server
nav_order: 8
---

{: .note}
> ì´ ê¸€ì„ ì½ê¸° ì „ì— Reactor ëª¨ë¸ ë“±ìž¥ ë°°ê²½ì„ ì„¤ëª…í•˜ëŠ” [https://ghkdqhrbals.github.io/portfolios/docs/Java/5](https://ghkdqhrbals.github.io/portfolios/docs/Java/5) ë¥¼ ë³´ê³  ì˜¤ì‹œë©´ ì´í•´ì— ë„ì›€ì´ ë  ê²ƒìž…ë‹ˆë‹¤!

ë³¸ í¬ìŠ¤íŒ…ì€ ì•„ëž˜ì˜ Referenceë“¤ì„ ë²ˆì—­í•˜ê³  ìž¬ì •ë¦¬í•œ ê¸€ìž…ë‹ˆë‹¤.

#### Reference
* [https://www.alibabacloud.com/blog/essential-technologies-for-java-developers-io-and-netty_597367](https://www.alibabacloud.com/blog/essential-technologies-for-java-developers-io-and-netty_597367)
* [https://medium.com/geekculture/a-tour-of-netty-5020ecee5494](https://medium.com/geekculture/a-tour-of-netty-5020ecee5494)

# 1. Netty ëž€?
## 1.1 Netty Architecture
ë„¤í‹°ëŠ” JVM ìœ„ì—ì„œ ëŒì•„ê°€ëŠ” Reactor I/O í”„ë ˆìž„ì›Œí¬ìž…ë‹ˆë‹¤.

ì´ì „ [Reactor Model](https://ghkdqhrbals.github.io/portfolios/docs/Java/5/#24-master-slave-reactor-model-multiple-reactors-and-threads) ì—ì„œ ì„¤ëª…í•œ Master-slave Reactor ëª¨ë¸ê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ ì¡°ê¸ˆ ë‹¤ë¥¸ë°ìš”. ì´ì œë¶€í„° ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.

![img](../../../assets/img/netty/8.webp)
![img](../../../assets/img/netty/10.png)

ë³´ì‹œë©´ í¬ê²Œ Boss Group, Worker Group, Executor Group ì´ ì„¸ ê°€ì§€ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ë‰˜ëŠ” ê²ƒì´ ë³´ì´ì£ ?

[Master-slave Reactor ëª¨ë¸](https://ghkdqhrbals.github.io/portfolios/docs/Java/5/#24-master-slave-reactor-model-multiple-reactors-and-threads)ê³¼ ë§¤ì¹­ì‹œì¼œë³´ë©´ 

* **Boss Group->Event Loop** = Main Reactor
* **Worker Group->Event Loop** = Sub Reactor
* **Executor Group** = Thread Pool 

ìœ„ì™€ ê°™ì´ ë§¤ì¹­ë©ë‹ˆë‹¤. ì¡°ê¸ˆì€ ë‹¤ë¥´ê² ì§€ë§Œìš”.

ìˆœì„œë¥¼ ë³¼ê¹Œìš”?

## 1.2 Netty ë™ìž‘ ìˆœì„œ

1. í´ë¼ì´ì–¸íŠ¸ ìš”ì²­
2. Boss Group ì€ í´ë¼ì´ì–¸íŠ¸ì™€ connection ìš”ì²­ì„ establish ë° NioSocket**Channel** ë¥¼ ë§Œë“­ë‹ˆë‹¤.
3. ê·¸ë¦¬ê³  Boss Group ì€ ìžì‹ ì˜ Event Loop ë¥¼ ëŒë¦¬ë©´ì„œ ëª¨ë“  NioSocketChannel ë¥¼ Worker Group ì˜ Nio Event Group ì´ ê´€ë¦¬í•˜ëŠ” selectorì— ë“±ë¡ì‹œí‚¤ì£ .
4. Worker Group ì˜ Event Loop ëŠ” ê³„ì† ëŒê³  ìžˆìŠµë‹ˆë‹¤. ì–˜ëŠ” ìžì‹ ì˜ selector ì— ì—°ê²°ëœ ì±„ë„ë“¤ì— ì´ë²¤íŠ¸ë¥¼ ê³„ì† Push í•´ì£¼ëŠ” ì—­í• ì„ ìˆ˜í–‰í•˜ì£ . ì¦‰, ìžì‹ ì˜ íì— ì €ìž¥ëœ ë„¤íŠ¸ì›Œí¬ Inbound ì´ë²¤íŠ¸ë¥¼ ë¹¼ì„œ NioSocketChannel ì— Push í•˜ê²Œ ë©ë‹ˆë‹¤.
5. NioSocketChannel ì—ì„œ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•˜ë©´, ChannelPipeline ì— ë“¤ì–´ê°‘ë‹ˆë‹¤.
6. ChannelPipeline ì€ ì—¬ëŸ¬ê°œì˜ ChannelHandlerê°€ ChannelContextì— ì˜í•´ linking ë˜ì–´ìžˆìŠµë‹ˆë‹¤. Inbound ì´ë²¤íŠ¸ëŠ” ì†Œì¼“ì„ ì½ì–´ì£¼ëŠ” `ChannelInboundHandler` ê°€ ì–˜ë¥¼ ì¸í„°ì…‰íŠ¸í•´ì„œ Taskë¥¼ ìˆ˜í–‰í•˜ê²Œ ë©ë‹ˆë‹¤.
7. ì´ ë•Œ, Executor Groupì˜ Thread Pool ì—ì„œ ìŠ¤ë ˆë“œë¥¼ ë¹¼ì™€ì„œ Taskë¥¼ ìˆ˜í–‰í•˜ê²Œ ë©ë‹ˆë‹¤.
8. ì´í›„, í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ìš”ì²­ì„ ë°˜í™˜í•˜ê¸° ìœ„í•œ `ChannelOutboundHandler` ê°€ í˜¸ì¶œë˜ê³  ì†Œì¼“ Writeë¥¼ í•˜ê²Œ ë©ë‹ˆë‹¤.

{: .important}
> ì¢…í•©í•˜ë©´ Boss Group ì€ Worker Group ë‚´ ì—¬ëŸ¬ ì´ë²¤íŠ¸ ë£¨í”„ë“¤ì—ê²Œ ê³„ì†í•´ì„œ ì´ë²¤íŠ¸ë¥¼ ì´ì£¼ê³ , ì´ë²¤íŠ¸ ë£¨í”„ëŠ” í•˜ë‚˜ì˜ selectorì„ ì´ìš©í•´ì„œ ì—¬ëŸ¬ ì±„ë„ê³¼ ì—¬ëŸ¬ í•¸ë“¤ëŸ¬ë¥¼ ìš´ì˜í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  í•¸ë“¤ëŸ¬ë“¤ì€ read/write ë§Œ ë‹´ë‹¹í•˜ë©° ì‹¤ì œ ë¡œì§ì€ Executor Groupì˜ Thread Pool ê³¼ ì—°ê²°ë˜ì–´ ìˆ˜í–‰ë˜ê²Œ ë©ë‹ˆë‹¤. Master-slave Reactor ëª¨ë¸ê³¼ ë§¤ìš° ìœ ì‚¬í•˜ì£ ?

## 1.3 Netty ìž¥ì 

ì´ë¥¼ í†µí•´ ë§Œì•½ íŠ¹ì • í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ì— ì‚¬ìš©ë˜ëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ì˜¤ëž˜ê±¸ë ¤ë„, ë‹¤ë¥¸ ìš”ì²­ë“¤ì€ blocking ë˜ì§€ ì•Šì£ ! ì™œëƒí•˜ë©´ HandlerëŠ” ë‹¨ìˆœížˆ read/write ë§Œì„ ë‹´ë‹¹í•˜ê¸° ë•Œë¬¸ì´ì£ . ì¦‰, **1. I/O ì™€ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ë¶„ë¦¬ì‹œí‚¨ ëª¨ë¸**ìž…ë‹ˆë‹¤. ë˜í•œ **2. I/O ê°€ ì‹œê°„ì´ ì˜¤ëž˜ ê±¸ë ¤ë„, ë‹¤ë¥¸ Channel ì—ê²Œ ì˜í–¥ì„ ì£¼ì§€ ì•Šê²Œ ë˜ì£ **. ì˜ˆë¡œ **ë„¤íŠ¸ì›Œí¬** Read/Write ì™€ **íŒŒì¼** Read/Write ëŠ” ì„œë¡œ ë¶„ë¦¬ëœ ì±„ë„(ì±„ë„ ë³„ Thread í• ë‹¹) ì´ê¸° ë•Œë¬¸ì—, íŒŒì¼ I/Oê°€ ì‹œê°„ì´ ì˜¤ëž˜ ê±¸ë ¤ë„ ë„¤íŠ¸ì›Œí¬ I/Oì—ëŠ” ì˜í–¥ì„ ì£¼ì§€ ì•Šì£ .

ë‹¤ì‹œí•œë²ˆ ì¢…í•©í•˜ë©´, NettyëŠ” **ë¹„ë™ê¸° non-blockingì— ìµœì í™”ëœ ëª¨ë¸**ì´ë¼ê³  ë³¼ ìˆ˜ ìžˆê² ìŠµë‹ˆë‹¤!

![img](../../../assets/img/netty/9.webp)

## 1.4 Netty Component Details

### 1.4.1 Channel

ë„¤í‹°ì˜ ì±„ë„ì€ NIO ì˜ ì±„ë„ê³¼ ë™ì¼í•˜ê²Œ read/writeì„ ìˆ˜í–‰í•˜ëŠ” ì»´í¬ë„ŒíŠ¸ìž…ë‹ˆë‹¤. `ChannelPipeline` ëŠ” ì—¬ëŸ¬ê°œì˜ `ChannelHandler` ë¡œ ì´ë£¨ì–´ì ¸ ìžˆìœ¼ë©°, `ChannelHandler` ëŠ” ì–‘ë°©í–¥ linked list ë¡œ ì—°ê²°ë˜ì–´ ìžˆìŠµë‹ˆë‹¤. Inbound/Outbound ì´ë²¤íŠ¸ë“¤ì€ `ChannelPipeline` ë¥¼ ê±°ì³ì„œ ë§žëŠ” `ChannelHandler` ë¡œ íë¥´ê²Œ ë˜ì£ . í•˜ë‚˜ì˜ `Channel`ì€ í•˜ë‚˜ì˜ `ChannelPipeline` ê³¼ ì—°ê²°ë˜ì–´ ìžˆìŠµë‹ˆë‹¤. `ChannelHandler` ì€ ì´ë²¤íŠ¸ë¥¼ Read/Write í•˜ëŠ” ì—­í• ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì‹¤ì œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ë“¤ì€ Executor Group ì˜ ìŠ¤ë ˆë“œí’€ì—ì„œ ìŠ¤ë ˆë“œ í•˜ë‚˜ ê°€ì ¸ì™€ ì²˜ë¦¬ë©ë‹ˆë‹¤.

> Channel is a component providing users a ways to process I/O operations, such as read and write.
A ChannelPipeline encapsulates a series of ChannelHandler instances as two-way linked list. Inbound and outbound events that flow through a channel can be intercepted by the ChannelPipeline. Whenever a channel is created, a ChannelPipeline is created and permanently bound to the channel. Triggered events can be intercepted, passed, ignored or terminated by ChannelHandler. The head of the linked list is HeadContext, and the tail of the linked list is TailContext.


### 1.4.2 ChannelHandlers

ì–˜ë„ ë§ˆì°¬ê°€ì§€ë¡œ NIO ì˜ Handlerì™€ ë™ì¼í•´ìš”. ì¡°ê¸ˆ ë‹¤ë¥¸ì ì€ PipeLine ë‚´ ì—¬ëŸ¬ê°œê°€ ChannelHandlerContext ì— ì˜í•´ ì–‘ë°©í–¥ linking ëœë‹¤ëŠ” ì ì´ì£ .

> ChannelHandlers Handles or intercepts events and forwards it to the next handler in a ChannelPipeline.
Based on its origin, an event is handled by the ChannelInboundHandler or ChannelOutboundHandler, and the ChannelHandlerContext forwards the event to the next ChannelHandler.

### 1.4.3 Netty NioEventLoopGroup

ì–˜ëŠ” í•˜ë‚˜ì˜ NIO selector, í•˜ë‚˜ì˜ í, í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë¡œ ë™ìž‘í•©ë‹ˆë‹¤. ì´ë²¤íŠ¸ë“¤ì„ íì— ë„£ê³  ê´€ë¦¬ë¥¼ í•˜ë©´ì„œ ì±„ë„ì— ê³„ì† ì—®ì–´ì£¼ëŠ” ì—­í• ì„ ìˆ˜í–‰í•˜ì£ .

> NioEventLoopGroup contains multiple NioEventLoops and manages their lifecycles. Each NioEventLoop contains an NIO selector, a queue, and a thread. The thread is used to poll the read and write events of the channels registered to the selector and handle the events that are delivered to the queue.
