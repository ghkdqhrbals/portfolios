---
layout: default
title: CompletableFuture vs WebFlux
parent: ğŸ“Œ Server
nav_order: 4
---

ì¼ë°˜ì ìœ¼ë¡œ Futureì™€ WebFlux ë¥¼ ë¹„ë™ê¸° êµ¬í˜„ì— ì‚¬ìš©í•˜ê²Œ ë©ë‹ˆë‹¤.
* **Future**ì€ ë³„ë„ì˜ ìŠ¤ë ˆë“œë¥¼ í˜¸ì¶œí•˜ì—¬ ë¡œì§ ì‹¤í–‰ í›„, CallBackì„ í†µí•´ ë¦¬í„´ê°’ì„ ì „ë‹¬ë°›ì„ ìˆ˜ ìˆì£ .
* **WebFlux**ëŠ” Flux/Mono ë¼ëŠ” ì´ë²¤íŠ¸ ìŠ¤íŠ¸ë¦¼ì„ ë§Œë“¤ê³ , í•´ë‹¹ ìŠ¤íŠ¸ë¦¼ì— Pub/Subí•˜ëŠ” ë°©ì‹ì´ì£ . `Flux/Mono`ëŠ” ì–´ë–»ê²Œ ë³´ë©´ ì´ë²¤íŠ¸ **ì±„ë„** ì´ë¼ê³  ë³¼ ìˆ˜ ìˆê² ì£ ? Fluxì™€ í•¨ê»˜ Sinks ê°ì²´ë¥¼ ì‚¬ìš©í•˜ê²Œ ëœë‹¤ë©´ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ì´ ì±„ë„ì— ë©”ì„¸ì§€ë¥¼ ì „ì†¡í•  ìˆ˜ ìˆêµ¬ìš”. ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë©”ì„¸ì§€ë¥¼ ë°›ì•„ë³¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

## 1. CompletableFuture vs WebFlux
## 1-1. Via ì»¨ì…‰

* **CompletableFuture** is async and can be non-blocking
* **CompletableFuture** is **eager**. You can't postpone the execution. But you can cancel them (which is better than nothing)
* **WebFlux** is async/non-blocking and can easily execute any call on different Thread by composing the main Mono with different operators.
* **WebFlux** is truly **lazy** and allows postponing execution **startup by the subscriber** presence and its readiness to consume data.


To enable WebFlux support in Spring Security 5, we only need to specify the @EnableWebFluxSecurity annotation:
```java
@EnableWebFluxSecurity
public class SecurityConfig {
    // ...
}
```

## 1-2. Via ì»¨íŠ¸ë¡¤ëŸ¬ ë©”ì†Œë“œ ë¦¬í„´íƒ€ì…

When the CompletableFuture is returned , it triggers **Servlet 3.0 asynchronous processing** feature which the execution of the CompletableFuture will be executed in other thread such that the server thread that handle the HTTP request can be free up as quickly as possible to process other HTTP requests. (See a series of blogpost start from this for detailed idea)

The @ResponseBody annotated on the @RestController will cause Spring to convert the controller method 's retuned value (i.e Person) through a HttpMessageConverter registered internally. One of its implementation is MappingJackson2HttpMessageConverter which will further delegate to the Jackson to serialise the Person object to a JSON string and send it back to the HTTP client by writing it to HttpServletResponse

Reference:[https://stackoverflow.com/questions/54866391/mono-vs-completablefuture](https://stackoverflow.com/questions/54866391/mono-vs-completablefuture)


