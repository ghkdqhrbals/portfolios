---
layout: default
title: Coroutine and VirutalThread
parent: Java-Kotlin
date: 2026-02-11
---

코루틴 매우 편리하고 콜백 지옥도 크게 해소되었다. 그런데 기존 Virtual Thread 와는 어떤 성능적 차이가 있는지 궁금해져서 찾아보았다.

[https://www.youtube.com/watch?v=zluKcazgkV4](https://www.youtube.com/watch?v=zluKcazgkV4) 에서 아래와 같이 말한다. coroutine 이 virtualthread 보다 매우매우 가볍고(메모리 사용률) 크게 3가지 부분때문에 그렇다고 한다. 이 중 맨 마지막인 suspend 함수 선언을 통한 컴파일러 최적화의 차이가 가장 정확한 것 같다. Loom 에선 당연히 컴파일링할 떄 바로 최적화가 안되니 메모리 사용률 관점에선 coroutine 이 훨씬 유리한 듯 함. 여기서는 JDK 20 을 기준으로 테스트했고 실제로 21부턴 virtualthread 가 더 개선되었을 것 같은데 찾아보진 않음.

![](../2026-02-11-17-23-59.png)

coroutine 쓸 때 주의해야할 점은, 코루틴 내 블로킹하는 기능이 있다면 Dispatcher.IO 라는 네이티브 스레드가 블로킹된다는 점이다(40:0초에 나옴). 커널 스레드는 아주 비싼데 이걸 블로킹해버리면 당연히 기존 장점이 모두 사라지며 오히려 성능이 더 안좋아진다. 그래서 VirtualThread 로 Dispacher.IO 네이티브 스레드말고 아래와 같이 사용하면 혹시모를 커널 스레드 블로킹 상황을 방지할 수 있다고 한다.

![](../2026-02-11-17-32-09.png)

그래서 결론은 **coroutine 은 쓰면 virtualthread 보다 메모리 덜 먹으면서 동시성을 향상시킬 수 있다. 반면 중간에 커널 스레드 블로킹이 발생할 수 있는 상황이라면 코루틴의 캐리어 스레드에 virtualthread 를 할당시켜서 블로킹으로부터 안전하게 실행하도록 하는게 좋다.**

