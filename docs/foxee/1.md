---
layout: default
title: 2. Controller í…ŒìŠ¤íŠ¸ ì‹œ, ControllerAdvice ë¯¸ì ìš© ë¬¸ì œì— ëŒ€í•œ ì—ëŸ¬ ì²˜ë¦¬ 
parent: ğŸ“Œ XAIë¥¼ í™œìš©í•œ ì·¨ì•½ì  ë¶„ì„ ì›¹ ì–´í”Œë¦¬ì¼€ì´ì…˜
nav_order: 2
---

updated at : 2023-08-26

## Description

Controller í…ŒìŠ¤íŠ¸ ì‹œ, ControllerAdvice ë¥¼ ê±°ì¹˜ì§€ ì•Šê³  ë°”ë¡œ Exception ì´ ë°˜í™˜ë˜ëŠ” ë¬¸ì œì ì´ ë°œê²¬ë˜ì—ˆì–´ìš”.
> ControllerAdvice ì„ ì§ì ‘ Mocking í•´ì£¼ì—ˆëŠ”ë°ë„ ë§ì´ì£ .


## Solution-1

ì•„ë˜ëŠ” Controller ì—ì„œ ì–´ë–¤ ê°ì²´ë¥¼ ë°˜í™˜í•˜ëƒì— ë”°ë¥¸ ControllerAdvice ìºì¹˜ ìœ ë¬´ë¥¼ ì„¤ëª…í•©ë‹ˆë‹¤.

> [@Async](https://www.baeldung.com/spring-async) shouldn't be used on controller methods as you would have one thread per request anyway. More details: [is using @Async and CompletableFuture in controller can increase performance of our api?](https://stackoverflow.com/questions/65120202/is-using-async-and-completablefuture-in-controller-can-increase-performance-of)
>
> If a service method like cachingService.storeFeedback takes long time to be completed and you want immediate response from endpoint then it could be annotated @Async in the service layer so cachingService.storeFeedback could be executed in the background.
>
> For controller method below, neither @ExceptionHandler nor [previous answer](https://stackoverflow.com/a/45060491/5962766) would help to return HTTP error response if exception would occur in the void @Async service method:
>
>
> ```java
> @RequestMapping(path = "", method = RequestMethod.PUT)
> public ResponseEntity<String> store(@Valid @RequestBody FeedbackRequest request, String clientSource) {
>     cachingService.storeFeedback(request, ClientSource.from(clientSource));
>     return new ResponseEntity<>(OK);
> }
> ```
>
> If controller would return Future from @Async service then @ExceptionHandler should be sufficient to handle endpoint errors:
>
> ```java
> @RequestMapping(path = "", method = RequestMethod.PUT)
> public CompletableFuture<String> store(@Valid @RequestBody FeedbackRequest request, String clientSource) {
>     return cachingService.storeFeedback(request, ClientSource.from(clientSource));
> }
> ```
>
> According to [How To Do @Async in Spring](https://www.baeldung.com/spring-async):
>
> When a method return type is a Future, exception handling is easy. Future.get() method will throw the exception.
>
> But if the return type is void, exceptions will not be propagated to the calling thread. So, we need to add extra configurations to handle exceptions.
>
> Reference: [https://stackoverflow.com/questions/44138199/spring-exceptionhandler-and-multi-threading](https://stackoverflow.com/questions/44138199/spring-exceptionhandler-and-multi-threading)

**ìœ„ì˜ ê¸€ì€ CompletableFuture ë“  Async ì–´ë…¸í…Œì´ì…˜ì´ë“  Service ë‹¨ ì—ì„œ ë¹„ë™ê¸°ë¡œ ë™ì‘í•˜ê³  ì˜ˆì™¸ë¥¼ ë°˜í™˜í•˜ë©´, ControllerAdvice ê°€ ì´ë¥¼ ìºì¹˜í•  ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒì„ ë§í•˜ê³  ìˆì£ !**

ì¦‰, ResponseEntity ë¥¼ ì•„ë˜ì™€ ê°™ì´ Controller ì˜ ë°˜í™˜ì— ë„£ê²Œ ë˜ë©´, ì´ë¥¼ ControllerAdvice ê°€ ì¡ì§€ ëª»í•©ë‹ˆë‹¤.
```java
public ResponseEntity<String> emailCodeSend(...){
    return ...;
}
```


ë”°ë¼ì„œ ì•„ë˜ì˜ ì½”ë“œì²˜ëŸ¼ Future ê°ì²´ë¥¼ ë°˜í™˜í•´ì£¼ì–´ì•¼ì§€ë§Œ ControllerAdvice ì—ì„œ ì´ë¥¼ ìºì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
```java
public CompletableFuture<ResponseEntity<String>> emailCodeSend(...){
    return ...;
}
```

í•˜ì§€ë§Œ ìœ„ì˜ ë°©ë²•ì„ ì ìš©í•´ë„ api í…ŒìŠ¤íŠ¸ì—ì„œ ì¡íˆì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.


## Solution-2

emailService ëŠ” ë¹„ë™ê¸°ë¡œ ë™ì‘í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì´ ë¹„ë™ê¸°ë¥¼ ê¸°ë‹¤ë ¤ì£¼ëŠ” mockMvcì˜ ë©”ì†Œë“œì¸ `getAsyncResult(long milli)` ëŠ” ControllerAdvice ë¥¼ ê±°ì¹˜ì§€ ì•Šì•„ìš”.
ê·¸ë˜ì„œ ì‚¬ì „ì— ë¹„ë™ê¸°ê¹Œì§€ ê°€ì§€ ì•Šë„ë¡ ì˜ˆìƒí•˜ëŠ” ê²°ê³¼ë¥¼ ì•„ë˜ì™€ ê°™ì´ ë¯¸ë¦¬ ì •ì˜í•˜ì˜€ìŠµë‹ˆë‹¤.

`when(emailService.checkVerificationCode(any(),any())).thenThrow(new CustomException(error));`

#### Full Code

```java
@Test
@DisplayName("[BaseControllerAdvice] ì˜ëª»ëœ ì¸ì¦ì½”ë“œë¥¼ ì „ì†¡í•˜ë©´ BaseControllerAdvice ê°€ intercept í•˜ì—¬ ErrorResponse ë¥¼ ë°˜í™˜í•´ì•¼í•©ë‹ˆë‹¤")
void emailCodeVerif() throws Exception {
    // given
    ErrorCode error = ErrorCode.BAD_CODE;
    when(emailService.checkVerificationCode(any(),any())).thenThrow(new CustomException(error));

    // when
    String result = mockMvc
            .perform(post("/user/register/code/verify")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(VerifyEmailCodeRequest.builder().code("wrongCode").build()))
                    .session(session))
            .andDo(print())
            .andExpect(status().is(error.getHttpStatus().value()))
            .andReturn()
            .getResponse()
            .getContentAsString(StandardCharsets.UTF_8);

    ErrorResponse errorResponse = objectMapper.readValue(result, ErrorResponse.class);

    // then
    assertThat(errorResponse.getMessage()).isEqualTo(error.getDetail());
    assertThat(errorResponse.getCode()).isEqualTo(error.name());
}
```